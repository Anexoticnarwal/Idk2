<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Star Drift: Asteroid Dodge</title>
<style>
  :root {
    color-scheme: dark;
    --bg: #0a0f1e;
    --fg: #b5c7ff;
    --hud: rgba(255,255,255,0.08);
    --accent: #6fa8ff;
    --danger: #ff6f6f;
    --ok: #5cffb1;
  }
  html, body { margin:0; padding:0; background:var(--bg); height:100%; overflow:hidden; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
  #game { display:block; width:100vw; height:100vh; touch-action:none; }
  .hud {
    position:fixed; top:0; left:0; right:0; display:flex; justify-content:space-between; align-items:center;
    padding:8px 10px; color:var(--fg); font-size:14px; background:linear-gradient(to bottom, rgba(0,0,0,0.35), transparent);
    z-index:10;
  }
  .hud .pill { background:var(--hud); border:1px solid rgba(255,255,255,0.12); border-radius:12px; padding:6px 10px; display:inline-flex; gap:10px; align-items:center; }
  .hud .right { display:flex; align-items:center; gap:8px; }
  .badge { display:inline-block; padding:2px 6px; border-radius:8px; border:1px solid rgba(255,255,255,0.15); background:rgba(255,255,255,0.06); font-size:12px; }
  .notif {
    position:fixed; left:50%; transform:translateX(-50%); bottom:16px; color:#fff; background:rgba(0,0,0,0.5);
    border:1px solid rgba(255,255,255,0.2); border-radius:8px; padding:8px 12px; font-size:14px; pointer-events:none; z-index:12; display:none;
  }
  .controls {
    position:fixed; bottom:16px; left:16px; right:16px; display:flex; justify-content:space-between; align-items:center; z-index:11;
    pointer-events:auto;
  }
  .stick {
    width:140px; height:140px; border-radius:50%; background:rgba(255,255,255,0.04); border:1px solid rgba(255,255,255,0.15);
    position:relative; touch-action:none;
  }
  .nub {
    width:56px; height:56px; border-radius:50%; background:rgba(255,255,255,0.15); border:2px solid rgba(255,255,255,0.35);
    position:absolute; left:50%; top:50%; transform:translate(-50%, -50%);
  }
  .btn {
    width:90px; height:90px; border-radius:50%; background:rgba(255,255,255,0.06); border:1px solid rgba(255,255,255,0.2);
    color:var(--fg); display:flex; align-items:center; justify-content:center; font-weight:600; touch-action:manipulation;
  }
  .btn:active { background:rgba(255,255,255,0.1); }
  @media (min-width: 900px) { .controls { display:none; } }
  .overlay {
    position:fixed; inset:0; display:none; align-items:center; justify-content:center; color:var(--fg); z-index:13;
    backdrop-filter: blur(3px) brightness(0.9);
  }
  .overlay.active { display:flex; }
  .card {
    background:rgba(0,0,0,0.5); border:1px solid rgba(255,255,255,0.15); border-radius:12px; padding:16px; width:min(90vw, 640px);
  }
  .card h2 { margin-top:0; }
  .shop { display:flex; gap:8px; flex-wrap:wrap; margin-top:8px; }
  .shop button {
    background:rgba(255,255,255,0.08); border:1px solid rgba(255,255,255,0.18); border-radius:8px; color:var(--fg);
    padding:8px 10px; cursor:pointer;
  }
  .shop button:disabled { opacity:0.5; cursor:not-allowed; }
</style>
</head>
<body>
  <canvas id="game" aria-label="Space game" role="img"></canvas>

  <div class="hud">
    <div class="pill">
      <span>HP:</span><span id="hp">100</span>
      <span>Shield:</span><span id="shield">0</span>
      <span>Score:</span><span id="score">0</span>
      <span>Wave:</span><span id="wave">1</span>
      <span>Credits:</span><span id="credits">0</span>
    </div>
    <div class="right">
      <span class="badge" id="weapon">Blaster</span>
      <span class="badge" id="speed">Speed: 1.0x</span>
      <span class="badge" id="fps">FPS</span>
      <span class="badge">K: Save | L: Load</span>
    </div>
  </div>

  <div class="controls" aria-hidden="false">
    <div class="stick" id="stick"><div class="nub" id="nub"></div></div>
    <div class="btn" id="fireBtn" aria-label="Fire">FIRE</div>
  </div>

  <div class="overlay" id="planetOverlay">
    <div class="card">
      <h2>Planet upgrade station</h2>
      <p>Safe zone. Game is paused while docked. Press Esc or leave the planet to resume.</p>
      <div>Credits: <span id="shopCredits">0</span> | Wave: <span id="shopWave">1</span></div>
      <div class="shop">
        <button id="upCannon">+Damage (cost scales)</button>
        <button id="upRate">+Fire rate (cost scales)</button>
        <button id="upEngine">+Speed (cost scales)</button>
        <button id="upShield">+Shield (cost scales)</button>
        <button id="repairHull">Repair to 100 HP</button>
        <button id="doubleShot">Unlock Double Shot</button>
        <button id="pierceRounds">Unlock Piercing Rounds</button>
        <button id="droneAlly">Deploy Drone Ally</button>
        <button id="timeWarp">Install Time Warp</button>
        <button id="saveBtn">Save (K)</button>
        <button id="loadBtn">Load (L)</button>
      </div>
      <p class="small">Upgrade power and cost scale with wave. Early waves are limited; late waves become extreme.</p>
    </div>
  </div>

  <div class="notif" id="notif"></div>

  <script>
  (() => {
    // Canvas
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d', { alpha: false });
    let W = 0, H = 0, DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    function resize() {
      W = Math.floor(window.innerWidth);
      H = Math.floor(window.innerHeight);
      canvas.width = Math.floor(W * DPR);
      canvas.height = Math.floor(H * DPR);
      canvas.style.width = W + 'px';
      canvas.style.height = H + 'px';
      ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
    }
    window.addEventListener('resize', resize);
    resize();

    // UI elements
    const hpEl = document.getElementById('hp');
    const shieldEl = document.getElementById('shield');
    const scoreEl = document.getElementById('score');
    const waveEl = document.getElementById('wave');
    const creditsEl = document.getElementById('credits');
    const weaponEl = document.getElementById('weapon');
    const speedEl = document.getElementById('speed');
    const fpsEl = document.getElementById('fps');
    const notifEl = document.getElementById('notif');
    const planetOverlay = document.getElementById('planetOverlay');
    const shopCredits = document.getElementById('shopCredits');
    const shopWave = document.getElementById('shopWave');

    // Shop buttons
    const btnCannon = document.getElementById('upCannon');
    const btnRate = document.getElementById('upRate');
    const btnEngine = document.getElementById('upEngine');
    const btnShield = document.getElementById('upShield');
    const btnRepair = document.getElementById('repairHull');
    const btnDouble = document.getElementById('doubleShot');
    const btnPierce = document.getElementById('pierceRounds');
    const btnDrone = document.getElementById('droneAlly');
    const btnTimeWarp = document.getElementById('timeWarp');
    const btnSave = document.getElementById('saveBtn');
    const btnLoad = document.getElementById('loadBtn');

    // Input
    const keys = new Set();
    window.addEventListener('keydown', (e) => {
      if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' '].includes(e.key)) e.preventDefault();
      if (e.key === 'Escape') unpauseFromPlanet();
      if (e.key.toLowerCase() === 'k') saveGame();
      if (e.key.toLowerCase() === 'l') loadGame();
      keys.add(e.key.toLowerCase());
    });
    window.addEventListener('keyup', (e) => keys.delete(e.key.toLowerCase()));

    // Mobile controls
    const stick = document.getElementById('stick');
    const nub = document.getElementById('nub');
    const fireBtn = document.getElementById('fireBtn');
    let joyActive = false, joyDX = 0, joyDY = 0, fireHeld = false;
    function setNub(x, y) { nub.style.left = (x * 50 + 50) + '%'; nub.style.top = (y * 50 + 50) + '%'; }
    function joyReset() { joyDX = 0; joyDY = 0; setNub(0,0); }
    stick.addEventListener('pointerdown', (e) => { joyActive = true; stick.setPointerCapture(e.pointerId); });
    stick.addEventListener('pointermove', (e) => {
      if (!joyActive) return;
      const r = stick.getBoundingClientRect(), cx = r.left + r.width/2, cy = r.top + r.height/2;
      const dx = (e.clientX - cx), dy = (e.clientY - cy);
      const max = r.width * 0.45;
      const len = Math.hypot(dx, dy);
      const nx = len > max ? dx * (max / len) : dx;
      const ny = len > max ? dy * (max / len) : dy;
      joyDX = nx / max; joyDY = ny / max;
      setNub(joyDX, joyDY);
    });
    stick.addEventListener('pointerup', () => { joyActive = false; joyReset(); });
    fireBtn.addEventListener('pointerdown', () => { fireHeld = true; });
    fireBtn.addEventListener('pointerup', () => { fireHeld = false; });

    // Helpers
    const TAU = Math.PI * 2;
    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
    const rand = (n=1) => Math.random() * n;
    const pick = (arr) => arr[Math.floor(rand(arr.length))];

    // World
    const world = { pois: [], parallax: [
      { stars: [], count: 140, speed: 0.08, color: '#98a6d6' },
      { stars: [], count: 90, speed: 0.2, color: '#b7c5ff' },
      { stars: [], count: 60, speed: 0.4, color: '#e0ecff' }
    ] };

    function genPlanets(count = 40) {
      world.pois.length = 0;
      for (let i = 0; i < count; i++) {
        const ang = rand(TAU), dist = 1500 + rand(22000);
        world.pois.push({
          type: 'planet',
          x: Math.cos(ang)*dist,
          y: Math.sin(ang)*dist,
          size: 60 + rand(60),
          hue: Math.floor(rand(360)),
          safeRadius: 700,
          name: 'Planet-' + (i+1)
        });
      }
    }
    genPlanets();

    // Player
    const player = {
      x: 0, y: 0, vx: 0, vy: 0, angle: 0,
      speed: 260, accel: 13, drag: 0.92,
      hp: 100, shield: 0, score: 0, credits: 0,
      fireCooldown: 0, weapon: 'Blaster', shotRate: 0.18,
      shotSpeed: 640, shotDamage: 10, shotSpread: 0, shotWidth: 2,
      doubleShot: false, pierce: false, hasDrone: false, timewarp: false,
      inSafeZone: false
    };

    // Entities
    const bullets = [];
    const asteroids = [];
    const particles = [];

    // Waves
    let waveLevel = 1;
    let paused = false;

    function startWave(level) {
      // Defined wave: starts with 10 asteroids at wave 1, scales up
      const count = Math.floor(10 + (level - 1) * 3.5);
      for (let i = 0; i < count; i++) spawnAsteroid(level);
      waveEl.textContent = level;
      shopWave.textContent = level;
    }

    function spawnAsteroid(level = waveLevel) {
      // Reduce spawns inside safe zones, but not zero
      if (player.inSafeZone && Math.random() < 0.85) return;
      const dist = 650 + rand(1000);
      const ang = rand(TAU);
      const x = player.x + Math.cos(ang) * dist;
      const y = player.y + Math.sin(ang) * dist;
      const r = 18 + rand(28) + level * 0.8;
      const hp = Math.round(30 + level * 6 + rand(20));
      const speed = 70 + level * 6 + rand(35);
      const dir = Math.atan2(player.y - y, player.x - x) + (rand(0.3) - 0.15);
      asteroids.push({ x, y, r, hp, vx: Math.cos(dir)*speed, vy: Math.sin(dir)*speed });
    }

    // Shooting
    function fire() {
      if (player.fireCooldown > 0) return;
      player.fireCooldown = player.shotRate;
      const baseAng = player.angle;
      const n = player.doubleShot ? 2 : 1;
      for (let i = 0; i < n; i++) {
        const ang = baseAng + (player.doubleShot ? (i === 0 ? -0.1 : 0.1) : 0);
        bullets.push({
          x: player.x + Math.cos(baseAng)*18,
          y: player.y + Math.sin(baseAng)*18,
          vx: Math.cos(ang)*player.shotSpeed + player.vx*0.25,
          vy: Math.sin(ang)*player.shotSpeed + player.vy*0.25,
          life: 1.3,
          w: player.shotWidth,
          dmg: player.shotDamage,
          pierce: player.pierce ? 2 : 0
        });
      }
    }

    // Notifications
    let notifTimer = 0;
    function notify(msg) {
      notifEl.textContent = msg;
      notifEl.style.display = 'block';
      notifTimer = 2.2;
    }

    // Save/Load
    function saveGame() {
      const data = {
        player: {
          hp: player.hp, shield: player.shield, score: player.score, credits: player.credits,
          shotDamage: player.shotDamage, shotRate: player.shotRate, speed: player.speed,
          doubleShot: player.doubleShot, pierce: player.pierce, hasDrone: player.hasDrone, timewarp: player.timewarp
        },
        waveLevel,
        pois: world.pois.map(p => ({
          type: p.type, x: p.x, y: p.y, size: p.size, hue: p.hue, safeRadius: p.safeRadius, name: p.name
        }))
      };
      try { localStorage.setItem('StarDriftSave', JSON.stringify(data)); notify('Progress saved'); shopCredits.textContent = player.credits; }
      catch (e) { notify('Save failed'); }
    }
    function loadGame() {
      const raw = localStorage.getItem('StarDriftSave');
      if (!raw) { notify('No save found'); return; }
      try {
        const data = JSON.parse(raw);
        const s = data.player;
        player.hp = s.hp; player.shield = s.shield; player.score = s.score; player.credits = s.credits;
        player.shotDamage = s.shotDamage; player.shotRate = s.shotRate; player.speed = s.speed;
        player.doubleShot = !!s.doubleShot; player.pierce = !!s.pierce; player.hasDrone = !!s.hasDrone; player.timewarp = !!s.timewarp;
        waveLevel = data.waveLevel || waveLevel;
        if (Array.isArray(data.pois) && data.pois.length) { world.pois = data.pois; }
        notify('Progress loaded'); shopCredits.textContent = player.credits; updateHUD();
        // Restart current wave enemies
        asteroids.length = 0; startWave(waveLevel);
      } catch (e) { notify('Load failed'); }
    }
    btnSave.addEventListener('click', saveGame);
    btnLoad.addEventListener('click', loadGame);

    // Parallax stars
    function initStars() {
      world.parallax.forEach(layer => {
        layer.stars.length = 0;
        for (let i = 0; i < layer.count; i++) {
          layer.stars.push({ x: rand(W), y: rand(H), s: 1 + Math.floor(rand(2)) });
        }
      });
    }
    initStars();

    // Transform
    function toScreen(x,y) { return { x: x - player.x + W/2, y: y - player.y + H/2 }; }

    // Edge-guidance arrow (shows only when close, disappears on arrival)
    function drawPOIArrow() {
      if (paused) return; // don't draw in shop
      let best = null, bestDist = Infinity;
      for (const p of world.pois) {
        if (p.type !== 'planet') continue;
        const d = Math.hypot(player.x - p.x, player.y - p.y);
        if (d < bestDist) { bestDist = d; best = p; }
      }
      if (!best) return;
      const arriveDist = best.size + 150;
      if (bestDist <= arriveDist) return; // reached target, hide arrow
      const showDist = 1200; // show only when relatively close
      if (bestDist > showDist) return;

      const ang = Math.atan2(best.y - player.y, best.x - player.x);
      const margin = 28; // smaller, less intrusive
      const cx = W/2, cy = H/2;
      const dx = Math.cos(ang), dy = Math.sin(ang);
      const rx = W/2 - margin, ry = H/2 - margin;
      const k = Math.min(Math.abs(rx / dx) || Infinity, Math.abs(ry / dy) || Infinity);
      const ex = cx + dx * Math.min(k, rx);
      const ey = cy + dy * Math.min(k, ry);

      ctx.save();
      ctx.translate(ex, ey);
      ctx.rotate(ang);
      ctx.fillStyle = 'rgba(255,207,111,0.7)';
      ctx.beginPath();
      ctx.moveTo(14, 0); ctx.lineTo(-7, -4); ctx.lineTo(-7, 4); ctx.closePath();
      ctx.fill();
      ctx.restore();
    }

    // Planet visuals + safe zone + shop (pauses game)
    function drawPlanet(p) {
      const s = toScreen(p.x, p.y);
      if (s.x < -p.size-200 || s.x > W+p.size+200 || s.y < -p.size-200 || s.y > H+p.size+200) return;

      const hue = p.hue;
      const base = `hsl(${hue}, 55%, 45%)`;
      const grad = ctx.createRadialGradient(s.x - p.size*0.25, s.y - p.size*0.25, p.size*0.25, s.x, s.y, p.size);
      grad.addColorStop(0, '#ffffff');
      grad.addColorStop(0.15, base);
      grad.addColorStop(1, '#0a0f1e');
      ctx.fillStyle = grad;
      ctx.beginPath(); ctx.arc(s.x, s.y, p.size, 0, TAU); ctx.fill();

      ctx.strokeStyle = `hsla(${hue}, 70%, 65%, 0.15)`;
      ctx.lineWidth = 3;
      ctx.beginPath(); ctx.arc(s.x, s.y, p.size + 2, 0, TAU); ctx.stroke();

      const d = Math.hypot(player.x - p.x, player.y - p.y);
      if (d < 900) {
        ctx.fillStyle = 'rgba(200,220,255,0.85)';
        ctx.font = '12px sans-serif';
        ctx.fillText(`${p.name}`, s.x + 10, s.y - p.size - 8);
      }

      const inSafe = d < p.safeRadius;
      if (inSafe) {
        player.inSafeZone = true;
        // Dock and pause when close to surface
        if (d < p.size + 140) {
          if (!paused) pauseAtPlanet();
        } else {
          if (paused) unpauseFromPlanet();
        }
      }
    }

    function pauseAtPlanet() {
      paused = true;
      planetOverlay.classList.add('active');
      shopCredits.textContent = player.credits;
      shopWave.textContent = waveLevel;
      updateShopAvailability();
    }
    function unpauseFromPlanet() {
      paused = false;
      planetOverlay.classList.remove('active');
    }

    // Shop scaling: power and costs increase with wave, limited early
    function upgradeCost(scaleBase, perWave) {
      return Math.floor(scaleBase + waveLevel * perWave);
    }
    function updateShopAvailability() {
      // Lock some features until later waves
      btnDouble.disabled = player.doubleShot || waveLevel < 5;
      btnPierce.disabled = player.pierce || waveLevel < 10;
      btnDrone.disabled = player.hasDrone || waveLevel < 15;
      btnTimeWarp.disabled = player.timewarp || waveLevel < 20;
      // Update labels to reflect dynamic costs/effects
      btnCannon.textContent = `+Damage (+${(1 + Math.floor(waveLevel/8))} dmg) — ${upgradeCost(18, 2)} cr`;
      btnRate.textContent = `+Fire rate (${Math.round(6 + waveLevel/4)}% faster) — ${upgradeCost(22, 3)} cr`;
      btnEngine.textContent = `+Speed (${Math.round(6 + waveLevel/5)}% faster) — ${upgradeCost(22, 3)} cr`;
      btnShield.textContent = `+Shield (+${Math.min(30 + Math.floor(waveLevel/2)*5, 120)}) — ${upgradeCost(12, 2)} cr`;
      btnRepair.textContent = `Repair to 100 HP — ${upgradeCost(8, 1)} cr`;
      btnDouble.textContent = player.doubleShot ? 'Double Shot unlocked' : `Unlock Double Shot — ${upgradeCost(35, 5)} cr`;
      btnPierce.textContent = player.pierce ? 'Piercing Rounds unlocked' : `Unlock Piercing Rounds — ${upgradeCost(45, 6)} cr`;
      btnDrone.textContent = player.hasDrone ? 'Drone Ally deployed' : `Deploy Drone Ally — ${upgradeCost(50, 7)} cr`;
      btnTimeWarp.textContent = player.timewarp ? 'Time Warp installed' : `Install Time Warp — ${upgradeCost(40, 7)} cr`;
    }

    // Shop actions
    function tryBuy(cost, apply) {
      if (player.credits >= cost) { player.credits -= cost; apply(); notify('Upgrade purchased'); updateHUD(); shopCredits.textContent = player.credits; }
      else notify('Not enough credits');
    }
    btnCannon.addEventListener('click', () => {
      const add = 1 + Math.floor(waveLevel/8); // scales slowly into late waves
      const cost = upgradeCost(18, 2);
      tryBuy(cost, () => { player.shotDamage += add; });
    });
    btnRate.addEventListener('click', () => {
      const pct = (6 + waveLevel/4) / 100;
      const cost = upgradeCost(22, 3);
      tryBuy(cost, () => { player.shotRate *= (1 - pct); player.shotRate = Math.max(0.06, player.shotRate); });
    });
    btnEngine.addEventListener('click', () => {
      const pct = (6 + waveLevel/5) / 100;
      const cost = upgradeCost(22, 3);
      tryBuy(cost, () => { player.speed *= (1 + pct); });
    });
    btnShield.addEventListener('click', () => {
      const add = Math.min(30 + Math.floor(waveLevel/2)*5, 120);
      const cost = upgradeCost(12, 2);
      tryBuy(cost, () => { player.shield = Math.min(120, player.shield + add); });
    });
    btnRepair.addEventListener('click', () => {
      const cost = upgradeCost(8, 1);
      tryBuy(cost, () => { player.hp = 100; });
    });
    btnDouble.addEventListener('click', () => {
      const cost = upgradeCost(35, 5);
      if (player.doubleShot) return;
      tryBuy(cost, () => { player.doubleShot = true; weaponEl.textContent = 'Double Blaster'; });
    });
    btnPierce.addEventListener('click', () => {
      const cost = upgradeCost(45, 6);
      if (player.pierce) return;
      tryBuy(cost, () => { player.pierce = true; });
    });
    btnDrone.addEventListener('click', () => {
      const cost = upgradeCost(50, 7);
      if (player.hasDrone) return;
      tryBuy(cost, () => { player.hasDrone = true; });
    });
    btnTimeWarp.addEventListener('click', () => {
      const cost = upgradeCost(40, 7);
      if (player.timewarp) return;
      tryBuy(cost, () => { player.timewarp = true; });
    });
    planetOverlay.addEventListener('click', (e) => { if (e.target === planetOverlay) unpauseFromPlanet(); });

    // Drone behavior
    const drone = { offset: 26, cooldown: 0, rate: 0.35 };
    function updateDrone(dt) {
      if (!player.hasDrone) return;
      drone.cooldown = Math.max(0, drone.cooldown - dt);
      if (drone.cooldown <= 0) {
        drone.cooldown = drone.rate;
        const ang = player.angle + 0.2;
        bullets.push({
          x: player.x + Math.cos(ang)*drone.offset,
          y: player.y + Math.sin(ang)*drone.offset,
          vx: Math.cos(ang) * (player.shotSpeed*0.8),
          vy: Math.sin(ang) * (player.shotSpeed*0.8),
          life: 1.2, w: 2, dmg: Math.max(6, player.shotDamage*0.7),
          pierce: player.pierce ? 1 : 0
        });
      }
    }

    // Drawing helpers
    function drawAsteroid(a) {
      const s = toScreen(a.x, a.y);
      if (s.x < -a.r-30 || s.x > W+a.r+30 || s.y < -a.r-30 || s.y > H+a.r+30) return;
      ctx.fillStyle = '#3e455d';
      ctx.beginPath();
      const sides = 6 + Math.floor(rand(3));
      for (let i=0;i<sides;i++) {
        const ang = i * TAU / sides;
        const rad = a.r * (0.78 + rand(0.22));
        const px = s.x + Math.cos(ang)*rad;
        const py = s.y + Math.sin(ang)*rad;
        if (i === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
      }
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle = 'rgba(230,240,255,0.12)';
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.strokeStyle = 'rgba(180,190,220,0.15)';
      ctx.beginPath();
      for (let i=0;i<2;i++){
        const ang = rand(TAU);
        ctx.moveTo(s.x + Math.cos(ang)*a.r*0.2, s.y + Math.sin(ang)*a.r*0.2);
        ctx.lineTo(s.x + Math.cos(ang)*a.r*0.85, s.y + Math.sin(ang)*a.r*0.85);
      }
      ctx.stroke();
    }
    function explode(x, y, color = '#ffd29e', n = 12) {
      for (let i = 0; i < n; i++) {
        const ang = rand(TAU), sp = 80 + rand(120);
        particles.push({ x, y, vx: Math.cos(ang)*sp, vy: Math.sin(ang)*sp, life: 0.5 + rand(0.5), color });
      }
    }

    // HUD
    function updateHUD() {
      hpEl.textContent = Math.max(0, Math.round(player.hp));
      shieldEl.textContent = Math.round(player.shield);
      scoreEl.textContent = player.score;
      creditsEl.textContent = player.credits;
      speedEl.textContent = `Speed: ${(player.speed/260).toFixed(1)}x`;
      weaponEl.textContent = player.doubleShot ? 'Double Blaster' : 'Blaster';
    }

    // Main loop
    let last = performance.now(), fpsAcc = 0, fpsFrames = 0, fps = 0;
    startWave(waveLevel);

    function loop(now) {
      requestAnimationFrame(loop);
      const dt = Math.min(0.033, (now - last) / 1000);
      last = now;

      // Pause logic: render some elements but skip updates
      if (paused) {
        // Background and planets still drawn below; skip movement/combat updates
      }

      // FPS
      fpsAcc += dt; fpsFrames++;
      if (fpsAcc >= 0.5) { fps = Math.round(fpsFrames / fpsAcc); fpsAcc = 0; fpsFrames = 0; fpsEl.textContent = `FPS: ${fps}`; }

      // Input
      const up = keys.has('arrowup') || keys.has('w') || joyDY < -0.15;
      const down = keys.has('arrowdown') || keys.has('s') || joyDY > 0.15;
      const left = keys.has('arrowleft') || keys.has('a') || joyDX < -0.15;
      const right = keys.has('arrowright') || keys.has('d') || joyDX > 0.15;
      const shooting = keys.has(' ') || fireHeld;

      if (!paused) {
        const ax = (right - left) * player.accel;
        const ay = (down - up) * player.accel;
        player.vx += ax; player.vy += ay;

        const maxV = player.speed;
        const vLen = Math.hypot(player.vx, player.vy);
        if (vLen > maxV) { const k = maxV / vLen; player.vx *= k; player.vy *= k; }
        player.vx *= player.drag; player.vy *= player.drag;
        player.x += player.vx * dt * 60 * 0.016;
        player.y += player.vy * dt * 60 * 0.016;
        if (vLen > 5) player.angle = Math.atan2(player.vy, player.vx);

        // Fire hold
        player.fireCooldown = Math.max(0, player.fireCooldown - dt);
        if (shooting) fire();

        // Drone
        updateDrone(dt);
      }

      // Safe zone detection
      player.inSafeZone = false;
      for (const p of world.pois) {
        if (p.type !== 'planet') continue;
        const d = Math.hypot(player.x - p.x, player.y - p.y);
        if (d < p.safeRadius) { player.inSafeZone = true; break; }
      }

      // Bullets
      if (!paused) {
        for (let i = bullets.length-1; i >= 0; i--) {
          const b = bullets[i];
          b.x += b.vx * dt;
          b.y += b.vy * dt;
          b.life -= dt;
          if (b.life <= 0) bullets.splice(i,1);
        }
      }

      // Asteroids
      if (!paused) {
        const slowFactor = player.timewarp ? 0.6 : 1;
        for (let i = asteroids.length-1; i >= 0; i--) {
          const a = asteroids[i];
          a.x += a.vx * dt * slowFactor;
          a.y += a.vy * dt * slowFactor;

          // Bullet hits
          for (let j = bullets.length-1; j >= 0; j--) {
            const b = bullets[j];
            if ((a.x-b.x)**2 + (a.y-b.y)**2 <= (a.r+3)**2) {
              a.hp -= b.dmg;
              if (b.pierce > 0) { b.pierce--; } else { bullets.splice(j,1); }
              if (a.hp <= 0) {
                player.score += Math.round(10 + a.r);
                player.credits += 5;
                explode(a.x, a.y);
                asteroids.splice(i,1);
                break;
              }
            }
          }

          // Player collision: damage scales with wave (start 5, increases)
          if ((a.x-player.x)**2 + (a.y-player.y)**2 <= (a.r+14)**2) {
            const base = 5;
            const scaled = Math.floor(waveLevel * 0.6); // increases with wave
            const dmg = base + scaled;
            if (player.shield > 0) {
              const absorb = Math.min(player.shield, dmg);
              player.shield -= absorb;
              player.hp -= (dmg - absorb);
            } else {
              player.hp -= dmg;
            }
            explode(player.x, player.y, '#ff7f7f', 8);
            const dx = a.x - player.x, dy = a.y - player.y, len = Math.hypot(dx, dy) || 1;
            a.vx += (dx/len) * 40; a.vy += (dy/len) * 40;

            if (player.hp <= 0) {
              // Lose 50% credits, respawn same wave
              player.credits = Math.floor(player.credits * 0.5);
              notify('Ship destroyed. Lost 50% credits. Respawning wave ' + waveLevel);
              respawnSameWave();
              break;
            }
          }
        }

        // If too few asteroids remain, push mini-batch to keep wave pressure
        const desired = Math.floor(10 + (waveLevel - 1) * 3.5);
        if (asteroids.length < Math.floor(desired * 0.35)) {
          const add = Math.min(5, desired - asteroids.length);
          for (let i = 0; i < add; i++) spawnAsteroid();
        }
      }

      // Particles
      for (let i = particles.length-1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx * dt; p.y += p.vy * dt; p.life -= dt;
        const s = toScreen(p.x, p.y);
        ctx.globalAlpha = Math.max(0, p.life);
        ctx.fillStyle = p.color;
        ctx.fillRect(s.x, s.y, 2, 2);
        ctx.globalAlpha = 1;
        if (p.life <= 0) particles.splice(i,1);
      }

      // Parallax
      ctx.fillStyle = '#060a16';
      ctx.fillRect(0,0,W,H);
      world.parallax.forEach(layer => {
        ctx.fillStyle = layer.color;
        const ox = -player.vx * layer.speed * dt;
        const oy = -player.vy * layer.speed * dt;
        for (const s of layer.stars) {
          s.x += ox; s.y += oy;
          if (s.x < 0) s.x += W; if (s.x >= W) s.x -= W;
          if (s.y < 0) s.y += H; if (s.y >= H) s.y -= H;
          ctx.fillRect(s.x|0, s.y|0, 1, 1);
        }
      });

      // Planets
      for (const p of world.pois) { if (p.type === 'planet') drawPlanet(p); }

      // Arrow
      drawPOIArrow();

      // Draw asteroids
      for (const a of asteroids) drawAsteroid(a);

      // Draw bullets
      ctx.strokeStyle = '#b7c5ff';
      for (const b of bullets) {
        const s = toScreen(b.x, b.y);
        ctx.lineWidth = b.w;
        ctx.beginPath();
        ctx.moveTo(s.x, s.y);
        ctx.lineTo(s.x - Math.cos(player.angle)*8, s.y - Math.sin(player.angle)*8);
        ctx.stroke();
      }

      // Player ship
      const px = W/2, py = H/2;
      ctx.save();
      ctx.translate(px, py);
      ctx.rotate(player.angle);
      ctx.fillStyle = '#7fb0ff';
      ctx.beginPath();
      ctx.moveTo(18, 0);
      ctx.lineTo(-12, -10);
      ctx.lineTo(-6, 0);
      ctx.lineTo(-12, 10);
      ctx.closePath();
      ctx.fill();
      if (player.shield > 0) {
        const alpha = clamp(player.shield / 120, 0.2, 0.7);
        ctx.strokeStyle = `rgba(92,255,177,${alpha})`;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(0,0, 16, 0, TAU);
        ctx.stroke();
      }
      ctx.restore();

      // HUD + notifications
      updateHUD();
      if (notifTimer > 0) { notifTimer -= dt; if (notifTimer <= 0) notifEl.style.display = 'none'; }
    }
    requestAnimationFrame(loop);

    function respawnSameWave() {
      player.hp = 100; player.shield = 0;
      player.x = 0; player.y = 0; player.vx = 0; player.vy = 0;
      bullets.length = 0; asteroids.length = 0; particles.length = 0;
      paused = false; planetOverlay.classList.remove('active');
      startWave(waveLevel);
      updateHUD();
    }

    // Respawn hotkey also keeps current wave (useful if stuck)
    window.addEventListener('keydown', (e) => {
      if (e.key.toLowerCase() === 'r') {
        notify('Respawning wave ' + waveLevel);
        respawnSameWave();
      }
    });

    // Tip
    window.addEventListener('load', () => {
      notify('Hold Space or tap FIRE to shoot. Dock at planets to shop.');
      setTimeout(() => { notifEl.style.display = 'none'; }, 3500);
    });
  })();
  </script>
</body>
</html>
